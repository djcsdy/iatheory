\chapter{Level Data} 

\begin{q}{Jeff Minter's Development Diary in Zzap Magazine\cite{planner}}
ACONT 

This is the bit that I knew would take me ages to write and get glitch
free, and the bit that is absolutely necessary to the functioning of the game.
The module ACONT is essentially an interpreter for my own 'wave language',
allowing me to describe, exactly, an attack wave in about 50 bytes of data. The
waves for the first part of IRIDIS are in good rollicking shoot-'em-up style,
and there have to be plenty of them. There are five planets and each planet is
to have twenty levels associated with it. It's impractical to write separate
bits of code for each wave; even with 64K you can run outta memory pretty fast
that way, and it's not really necessary coz a lot of stuff would be duplicated.
Hence ACONT.

\end{q}

The bits and bytes that define the behaviour and appearance of
wave after wave of Iridis Alpha's enemy formations - twenty across each of the
five planets giving on hundred in all - takes up relatively little space given
the sheer variety of adversaries the player faces.

\subsection{You're a Waste of Space}
Each 'wave' of enemies is defined by a 40 byte data structure, not 50 bytes as
Minter initially suggested in his development diary. There's a little bit of 
waste going on in here too, bytes 10 to 14 are unused, while \icode{Byte 15} is only
ever set (to \icode{\$01}) by the wave data structure that describes the default explosion 
behaviour for enemy ships.

As we can see here, the sole purpose of \icode{Byte 15} is to determine whether a
new set of wave data needs to be loaded. This makes sense, once the animation is finished
we'll need to load a new enemy ship. Still, you can't help thinking there might have been 
a way that didn't waste 99 bytes! 

\lstinputlisting[style=6502Style,firstline=1963,lastline=1980]{../iridisalpha/src/iridisalpha.asm}

And actually, it's more than that because as we shall see the \icode{ACONT} 40-byte data
structure is defined more than once per wave. Separate instances are defined for later
phases of the enemy ship, such as when it is first hit. Early examples of this in the game
are the 'spinning rings' you get when you hit an enemy in the first level.

In all there are 200 instances of the \icode{ACONT} data structure: 100 defining each of the
enemy waves and another 100 defining the subsequent behaviour of the ships when hit. There isn't
a one-to-one mapping here either - many of the effects are reused across levels and as we shall
see there can be multiple stages in an enemy's lifecycle.

So there's already 1000 bytes or 1 kilobyte of wasted space in the level data due to bytes
that are never or rarely used. That's out of a total of 8 kilobytes actually used.

Shocking stuff. Awful.


\subsection{Clever Business}
\begin{q}{Jeff Minter's Development Diary in Zzap Magazine\cite{planner}}
You pass the interpreter data, that describes exactly stuff like: what each
alien looks like, how many frames of animation it uses, speed of that
animation, colour, velocities in X— and Y— directions, accelerations in X and
Y, whether the alien should 'home in' on a target, and if so, what to home in
on; whether an alien is subject to gravity, and if so, how strong is the
gravity; what the alien should do if it hits top of screen, the ground, one of
your bullets, or you; whether the alien can fire bullets, and if so, how
frequently, and what types; how many points you get if you shoot it, and how
much damage it does if it hits you; and a whole bunch more stuff like that. As
you can imagine it was a fairly heavy routine to write and get debugged, but
that's done now; took me about three weeks in all I'd say.
\end{q}

The level data does actually define some of this stuff. It does so by making
heavy use of a simple but clever trick that in its way is very specific to
8-bit assembly programming: storing references to other data structures as
a pair of bytes. We've discussed the way this works previously but we'll try
again briefly here as it won't do any harm. 

The 40-byte data structure that defines the default explosion animation (and
behaviour, so far as it goes) is stored at position \icode{\$18C8} while the
game is running. To use this explosion data when an enemy is killed, bytes 31
and 32 of the data structure contain the values \icode{\$C8,\$18}. 

When an enemy is hit, the game routine responsible for figuring out what to do next
with it looks at bytes 31 and 32 and loads in the data structure at the address
given by combining \icode{\$18} and \icode{\$C8} as the 'new' wave data that
defines how that enemy ship will now behave. Since the data structure at
\icode{\$18C8} basically says: animate an explosion sprite and don't move
anywhere that is exactly what the enemy ship now does.

Here's the explosion data structure, which we've labelled \icode{defaultExplosion} in
our disassembly, in the first twenty bytes or so of it's gory detail:

\lstinputlisting[basicstyle=\tiny,style=6502Style,firstline=4276,lastline=4310]{../iridisalpha/src/level_data/level_data2.asm}

We can see the first 7 bytes are concerned with the appearance and basic behaviour of the
enemy. Bytes 2 and 3 define the sprite used for display on the upper planet, Bytes 5 and 6
for the lower planet. The reason there's two in each case is because they are describing the
start and end point of the sprite's animation. The game will display \icode{EXPLOSION\_START} \icode{\$ED}) first,
then cycle through the next two sprites until it reaches \icode{EXPLOSION\_START} + 3 (\icode{\$F0}). 

\subsection{And You're a Waste of Space}

\icode{Bytes 33 - 34} seem to be left in an unfinished state. Wave 12 on Planet 5 has both populated, \icode{flowchartArrowAsExplosion}
is the only other wave that has anything in either byte, in this case \icode{\$60} in \icode{Byte 33}.

This another 200 wasted bytes it seems but it seems these bytes have some game logic attached and
when you look at what that logic is doing it seems broken.

\lstinputlisting[basicstyle=\tiny,style=6502Style,firstline=1945,lastline=1958]{../iridisalpha/src/iridisalpha.asm}

When Byte 34 (\icode{\$21}) is populated (and fire has not been pressed) the game will attempt to load
a set of wave date from Bytes 33 and 34:

\lstinputlisting[basicstyle=\tiny,style=6502Style,firstline=1989,lastline=2006]{../iridisalpha/src/iridisalpha.asm}

In the case of the data for Planet 5 Level 12 this translates to whatever is at \icode{\$1488}. As it happens this 
is the address of the frequency data used in the title screen's music. So effectively pretty random data:

\lstinputlisting[basicstyle=\tiny,style=6502Style,firstline=659,lastline=673]{../iridisalpha/src/iridisalpha.asm}

Clearly, no one has ever reached level 12 in planet 5!

\subsection{Sprites Behaving Badly}

\subfile{level_data_sprites}

\subsection{Enemy Movement}

\subfile{level_data_movement}

\subsection{Enemy Behaviour}

\subfile{level_data_behaviour}

\subsection{Pointer Data}

\subfile{level_data_pointers}

